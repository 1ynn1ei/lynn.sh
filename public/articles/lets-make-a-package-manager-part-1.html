<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="English" xml:lang="English">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Let's make a package manager (1)</title>
<meta name="description" content="Let's write a package manager, from scratch, in the c programming language." />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<div id="content" class="content">
<div id="top-matter">
<p class="yeseva-one-regular">LYNN</p>
</div>
<a rel="me" href="https://tech.lgbt/@lynn_sh">Mastodon</a> | 
<a rel="me" href="https://codeberg.org/lynn_sh">Codeberg</a>
<hr>
<p>
<i>You can find the code for this portion here: <a href="https://codeberg.org/lynn_sh/romi/src/branch/ll/part-1">romi</a></i>
</p>
<div id="outline-container-org9a58433" class="outline-2">
<h2 id="org9a58433">Let's make a package manager (1)</h2>
<div class="outline-text-2" id="text-org9a58433">
<p>
<code>pacman</code>, <code>aptitude</code>, <code>portage</code>, <code>xbps</code>, and other linux package managers all have one thing in common: I didn't write them!
</p>

<p>
Sure, they do the job perfectly well and there is no reason to make any sort of replacement for them, but that's not the attitude anyone learns from. So why don't you join me as I try to figure out how to write the world's worst package manager for linux.
</p>
</div>
<div id="outline-container-org5e53758" class="outline-3">
<h3 id="org5e53758">What is a package manager</h3>
<div class="outline-text-3" id="text-org5e53758">
<p>
You should really know this, if you are here reading this article. I'll give you the benefit of the doubt, though. A package manager, in short, is software that automates the install, update, remove steps of software. It also configures it depending on the distributions' opinion. Yes, this means that there is actually more to installing something than:
</p>
<div class="org-src-container">
<pre class="src src-shell">sudo apt get {package}
</pre>
</div>

<p>
There is actually quite a lot more going on. All of the pain of configuring, building, and packing dependencies is pushed onto the particle package manager's maintainer(s).
</p>
</div>
</div>
<div id="outline-container-org794ae5c" class="outline-3">
<h3 id="org794ae5c">Anatomy of a package manager</h3>
<div class="outline-text-3" id="text-org794ae5c">
</div>
<div id="outline-container-orgd157d3b" class="outline-4">
<h4 id="orgd157d3b">Software to handle user input</h4>
<div class="outline-text-4" id="text-orgd157d3b">
<p>
This is what most people will recognize as a package manager. It takes in the package name, what action the user wants to do with it (<code>install</code>, <code>remove</code>, <code>update</code>, &amp;c) and any optional flags.
</p>
</div>
</div>
<div id="outline-container-org06abf26" class="outline-4">
<h4 id="org06abf26">Repository for supported packages</h4>
<div class="outline-text-4" id="text-org06abf26">
<p>
For a package manager to actually manage a package, it needs to know about it. The repository is a place to store information on how to get the package, where to get it, which build options it needs, and what patches or additional flags need to be set to maintain stability in the distribution it is serving. How all this information is stored varies from package manager; some such as <code>guix</code> writes all of this information out in declarative <code>guile scheme</code>, some like <code>xbps</code> write it in shell script. More on this decision later, when we talk about dependencies. 
</p>
</div>
</div>
<div id="outline-container-org65e7ead" class="outline-4">
<h4 id="org65e7ead">Software to build supported packages</h4>
<div class="outline-text-4" id="text-org65e7ead">
<p>
This is where the magic happens. The user's input and the repositories definition of the package come together here to build the dependencies and the package. If the package manager is source-based, as in the user is expected to build everything from source, this is in the same domain as the first software messaged. In other cases, this is used by people running build servers for the package manager, called mirrors. When a package definition is updated they rebuild it from definition, and host it on their mirror. Then, depending on the users definition of which mirrors to use, the user will retrieve the already-built package and move onto the next step.
</p>

<p>
Source-based package managers allow the user to build for their system and their hardware. It means the user can have a level of implicit trust, as they can theoretically audit the code before building.
</p>

<p>
The binary-based package managers are convenient for saving time and energy for the user, as they don't need to build anything. The packages are built for maximum compatibility, which can also make things easier for the user. The binary will have a hashed sum that the user (or, in almost all cases the software) will verify with before installing to reduce the surface area that is vulnerable to attack. 
</p>
</div>
</div>
<div id="outline-container-org827fc07" class="outline-4">
<h4 id="org827fc07">Installing the software</h4>
<div class="outline-text-4" id="text-org827fc07">
<p>
The final step of the journey for a package is putting it somewhere the user can use it. The software will also keep track of what it just installed, so the user can query the package manager at a later date about the package. More sophisticated package managers will also gracefully handle multiple versions of a dependency co-existing.
</p>
</div>
</div>
</div>

<div id="outline-container-org9c93db1" class="outline-3">
<h3 id="org9c93db1">What we are going to write</h3>
<div class="outline-text-3" id="text-org9c93db1">
<p>
Now that we know the general idea of what a package manager is, it's important to set goals and limitations for the project. This is a hobby project after all, and we don't need to burden ourselves with things like security issues, build servers, or most of the nice-to-have functionality described above. In fact, we are going to support only a single package for now.
</p>

<p>
<b>The following will be used to describe the package manager in it's repository:</b>
</p>

<p>
<i>A source-based hobby package manager, written to assist minimal systems with package maintenance and installation. Packages are always built from source, from a tarball, definitions are written in shell script to reduce dependencies as much as possible. Dependencies will be described in the definition for a package, but if a dependency is then updated by the user directly there will be no further checks for compatibility.</i>
</p>
</div>
</div>

<div id="outline-container-org626431d" class="outline-3">
<h3 id="org626431d">Let's get cracking</h3>
<div class="outline-text-3" id="text-org626431d">
<p>
First, for this project I've decided on a code-name of <code>romi</code>, and the package repository as <code>romi-pkgs</code>. I'll be referring to them as such from now on.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;curl/curl.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;getopt.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;stdio.h&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;string.h&gt;</span>


<span class="org-keyword">const</span> <span class="org-type">char</span> *<span class="org-variable-name">myname</span>;
<span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-variable-name">verbose_flag</span>, <span class="org-variable-name">dry_run_flag</span>;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-keyword">struct</span> <span class="org-type">option</span> <span class="org-variable-name">long_options</span>[]
    = { { <span class="org-string">"verbose"</span>, no_argument, &amp;verbose_flag, 1 },
        { <span class="org-string">"dry"</span>, no_argument, &amp;dry_run_flag, 1 },
        { <span class="org-constant">NULL</span>, 0, <span class="org-constant">NULL</span>, <span class="org-string">'\0'</span> } };
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">download</span> (<span class="org-type">char</span> *);
<span class="org-keyword">struct</span> <span class="org-type">pkg</span>
{
  <span class="org-type">char</span> *<span class="org-variable-name">name</span>, *<span class="org-variable-name">fname</span>, *<span class="org-variable-name">url</span>, *<span class="org-variable-name">version</span>;
};

<span class="org-type">int</span>
<span class="org-function-name">main</span> (<span class="org-type">int</span> <span class="org-variable-name">argc</span>, <span class="org-type">char</span> **<span class="org-variable-name">argv</span>)
{
  <span class="org-keyword">if</span> (argc &lt; 2)
    <span class="org-keyword">return</span> -1;
  myname = argv[0];

  <span class="org-type">int</span> <span class="org-variable-name">c</span>;
  <span class="org-keyword">while</span> ((c = getopt_long (argc, argv, <span class="org-string">"vd"</span>, long_options, <span class="org-constant">NULL</span>)) != -1)
    {
      <span class="org-keyword">switch</span> (c)
        {
        <span class="org-keyword">case</span> <span class="org-string">'v'</span>:
          verbose_flag = 1;
          <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> <span class="org-string">'d'</span>:
          dry_run_flag = 1;
          <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> 0:
          <span class="org-comment-delimiter">/* </span><span class="org-comment">Do nothing</span><span class="org-comment-delimiter"> */</span>
          <span class="org-keyword">break</span>;
        }
    }
  <span class="org-keyword">while</span> (argv[optind] != <span class="org-constant">NULL</span>)
    {
      download (argv[optind]); <span class="org-comment-delimiter">// </span><span class="org-comment">single thread performance!</span>
      optind += 1;
    }
}
</pre>
</div>

<p>
I won't go over too much here because it is pretty standard boiler-plate. Yes, it is in <code>GNU</code> coding style. If you are confused about <code>long_options</code>, <code>getopt_long</code>, or <code>optind</code> I recommend reading the documentation for <code>getopt</code>, one of our dependencies.
</p>

<p>
We also need to add the <code>libcurl</code> to our linker:
</p>

<div class="org-src-container">
<pre class="src src-makefile"><span class="org-variable-name">CC</span> = gcc
<span class="org-variable-name">CFLAGS</span>=-Wall
<span class="org-variable-name">LDFLAGS</span>=-lcurl
<span class="org-makefile-targets">all</span>: main.o
        $(<span class="org-variable-name">CC</span>) $(<span class="org-variable-name">CFLAGS</span>) -o romi main.o $(<span class="org-variable-name">LDFLAGS</span>)

<span class="org-makefile-targets">main.o</span>: main.c
        $(<span class="org-variable-name">CC</span>) -c main.c $(<span class="org-variable-name">CFLAGS</span>)
<span class="org-makefile-targets">clean</span>:
        rm -rf romi main.o
<span class="org-makefile-targets">.PHONY</span>:
        all
</pre>
</div>

<p>
Finally we are going to define our download function. For now, it will only accept a single package: <code>binutils</code>. Specifically, version <code>2.42</code>, acquired from the <code>ftp.gnu.org</code> server. Let's have a look:
</p>
<div class="org-src-container">
<pre class="src src-c"><span class="org-type">void</span>
<span class="org-function-name">download</span> (<span class="org-type">char</span> *<span class="org-variable-name">query</span>)
{
  <span class="org-type">CURL</span> *<span class="org-variable-name">curl</span>;
  <span class="org-type">FILE</span> *<span class="org-variable-name">fp</span>;
  <span class="org-type">CURLcode</span> <span class="org-variable-name">response</span>;
  <span class="org-keyword">struct</span> <span class="org-type">pkg</span> <span class="org-variable-name">package</span>;
  <span class="org-keyword">if</span> (strcmp (query, <span class="org-string">"binutils"</span>) == 0)
    {
      package.name = <span class="org-string">"binutils"</span>;
      package.url = <span class="org-string">"https://ftp.gnu.org/gnu/binutils/binutils-2.42.tar.xz"</span>;
      package.version = <span class="org-string">"2.42"</span>;
      package.fname = <span class="org-string">"binutils-2.42.tar.xz"</span>;
    }
  fp = fopen (package.fname, <span class="org-string">"wb"</span>);
  curl = curl_easy_init ();
  curl_easy_setopt (curl, CURLOPT_URL, package.url);
  curl_easy_setopt (curl, CURLOPT_WRITEDATA, fp);
  <span class="org-keyword">if</span> (verbose_flag)
    curl_easy_setopt (curl, CURLOPT_VERBOSE, 1L);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>dry_run_flag)
    response = curl_easy_perform (curl);
  <span class="org-keyword">if</span> (response == CURLE_OK)
    {
      <span class="org-comment-delimiter">// </span><span class="org-comment">TODO</span>
    }
  curl_easy_cleanup (curl);
  fclose (fp);
}
</pre>
</div>

<p>
The <code>pkg</code> struct helps inform us of information that will be changing package to package, and how we might want to store that information in the future in our <code>romi-pkgs</code> repository.
</p>

<p>
Let's test it out now. if we run:
</p>
<div class="org-src-container">
<pre class="src src-shell">make
./romi binutils
</pre>
</div>
<p>
Nothing will happen for a few seconds, depending on your download speed, and then the program will exit. if we then <code>ls</code> we will see that the <code>binutils-2.42.tar.xz</code> has been added to the directory we are currently in.
</p>

<p>
If we add the verbose tag, we pass it along to curl and you can see the actual nitty gritty details of the exchange:
</p>
<div class="org-src-container">
<pre class="src src-shell">./romi binutils -v
./romi binutils --verbose
</pre>
</div>

<p>
I'll leave it up to you to figure out what the <code>dry-run</code> flag does!
</p>
</div>
</div>

<div id="outline-container-orga9c54d6" class="outline-3">
<h3 id="orga9c54d6">Wrapping up</h3>
<div class="outline-text-3" id="text-orga9c54d6">
<p>
We set our definition for our package manager, wrote some code and managed to pull exactly one package with some metadata. Next time, we are going to write some shell scripts to unpack the file, set our configurations, and then build it.
</p>

<p>
The combination of the metadata we need for our <code>struct pkg</code>, combined with the inputs for those shell scripts, will give us the full picture of how we want to define our packages in our repository. 
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.4 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p>
</div>
</body>
</html>
